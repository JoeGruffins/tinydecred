from tinydecred.crypto.bytearray import ByteArray
from tinydecred.pydecred.txscript import Signature


def test_signature():
    class test:
        def __init__(self, name, sig, der, isValid):
            self.name = name
            self.sig = sig
            self.der = der
            self.isValid = isValid

    # fmt: off
    tests = [
        # signatures from bitcoin blockchain tx
        # 0437cd7f8525ceed2324359c2d0ba26006d92d85
        test(
            "valid signature.",
            [0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            True,
        ),
        test(
            "empty.",
            [],
            "",
            False,
        ),
        test(
            "bad magic.",
            [0x31, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "bad 1st int marker magic.",
            [0x30, 0x44, 0x03, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "bad 2nd int marker.",
            [0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x03, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "short len",
            [0x30, 0x43, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "long len",
            [0x30, 0x45, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "long X",
            [0x30, 0x44, 0x02, 0x42, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "long Y",
            [0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x21, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "short Y",
            [0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x19, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "trailing crap.",
            [0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09, 0x01],
            True,
            # This test is now passing (used to be failing) because there
            # are signatures in the blockchain that have trailing zero
            # bytes before the hashtype. So ParseSignature was fixed to
            # permit buffers with trailing nonsense after the actual
            # signature.
            True,
        ),
        test(
            "X == N ",
            [0x30, 0x44, 0x02, 0x20, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48,
                0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "X == N ",
            [0x30, 0x44, 0x02, 0x20, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48,
                0xA0, 0x3B, 0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41,
                0x42, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            False,
            False,
        ),
        test(
            "Y == N",
            [0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
                0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41],
            True,
            False,
        ),
        test(
            "Y > N",
            [0x30, 0x44, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFE, 0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
                0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x42],
            False,
            False,
        ),
        test(
            "0 len X.",
            [0x30, 0x24, 0x02, 0x00, 0x02, 0x20, 0x18, 0x15,
                0x22, 0xec, 0x8e, 0xca, 0x07, 0xde, 0x48, 0x60, 0xa4,
                0xac, 0xdd, 0x12, 0x90, 0x9d, 0x83, 0x1c, 0xc5, 0x6c,
                0xbb, 0xac, 0x46, 0x22, 0x08, 0x22, 0x21, 0xa8, 0x76,
                0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "0 len Y.",
            [0x30, 0x24, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x00],
            True,
            False,
        ),
        test(
            "extra R padding.",
            [0x30, 0x45, 0x02, 0x21, 0x00, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x20, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        test(
            "extra S padding.",
            [0x30, 0x45, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x21, 0x00, 0x18, 0x15, 0x22, 0xec, 0x8e, 0xca,
                0x07, 0xde, 0x48, 0x60, 0xa4, 0xac, 0xdd, 0x12, 0x90,
                0x9d, 0x83, 0x1c, 0xc5, 0x6c, 0xbb, 0xac, 0x46, 0x22,
                0x08, 0x22, 0x21, 0xa8, 0x76, 0x8d, 0x1d, 0x09],
            True,
            False,
        ),
        # Standard checks (in BER format, without checking for 'canonical' DER
        # signatures) don't test for negative numbers here because there isn't
        # a way that is the same between openssl and go that will mark a number
        # as negative. The Go ASN.1 parser marks numbers as negative when
        # openssl does not (it doesn't handle negative numbers that I can tell
        # at all. When not parsing DER signatures, which is done by by bitcoind
        # when accepting transactions into its mempool, we otherwise only check
        # for the coordinates being zero.
        test(
            "X == 0",
            [0x30, 0x25, 0x02, 0x01, 0x00, 0x02, 0x20, 0x18,
                0x15, 0x22, 0xec, 0x8e, 0xca, 0x07, 0xde, 0x48, 0x60,
                0xa4, 0xac, 0xdd, 0x12, 0x90, 0x9d, 0x83, 0x1c, 0xc5,
                0x6c, 0xbb, 0xac, 0x46, 0x22, 0x08, 0x22, 0x21, 0xa8,
                0x76, 0x8d, 0x1d, 0x09],
            False,
            False,
        ),
        test(
            "Y == 0.",
            [0x30, 0x25, 0x02, 0x20, 0x4e, 0x45, 0xe1, 0x69,
                0x32, 0xb8, 0xaf, 0x51, 0x49, 0x61, 0xa1, 0xd3, 0xa1,
                0xa2, 0x5f, 0xdf, 0x3f, 0x4f, 0x77, 0x32, 0xe9, 0xd6,
                0x24, 0xc6, 0xc6, 0x15, 0x48, 0xab, 0x5f, 0xb8, 0xcd,
                0x41, 0x02, 0x01, 0x00],
            False,
            False,
        ),
    ]
    # fmt: on
    for test in tests:
        try:
            Signature.parse(ByteArray(test.sig), test.der)
        except Exception:
            assert test.isValid is False
